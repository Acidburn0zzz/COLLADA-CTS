// Copyright (c) 2012 The Khronos Group Inc.
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and /or associated documentation files (the "Materials "), to deal in the Materials without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Materials, and to permit persons to whom the Materials are furnished to do so, subject to 
// the following conditions: 
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Materials. 
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.


// HierarchyPreservationChecking.cpp : Defines the entry point for the console application.
// This module is used to check for two DAE files, whether the hierarchy of visual scene graph is equalivant to each other or not.
#define NUM_TREES (2)

#include "HierarchyPreservationChecking.h"

NodeHPChecker::NodeHPChecker(daeDocument *pDoc1, daeDocument *pDoc2, domVisual_scene *pRoot1, domVisual_scene *pRoot2)
{
	// init visual scenes and documents
	pVisualScene[0] = pRoot1;
	pVisualScene[1] = pRoot2;

	pDocument[0]	= pDoc1;
	pDocument[1]	= pDoc2;

	// set basic string
	strBasicName.assign("HierarchyPreservation");

	// index for no name string
	giIndexNoName = 0;

	// Generate local tree of node here
	InitRoots();
}

NodeHPChecker::~NodeHPChecker()
{
	// To do: recursively clean both Tree nodes

}

bool NodeHPChecker::InitRoots()
{
	for (int j = 0; j < NUM_TREES;j++)
	{
		pRoot[j] = new TreeNode();

		GeneratingName(pRoot[j]);

		// new root pointers
		domNode_Array& aNodes = pVisualScene[j]->getNode_array();

		// add each node to root
		for ( size_t i = 0; i < aNodes.getCount(); i++ ) 
		{
			TreeNode * pChild = new TreeNode();

			// Load current dom node
			// Append child
			pRoot[j]->AppendChildren( LoadNode(aNodes.get(i), pRoot[j]) );

			pChild->SetParent(pRoot[j]);
		}

		// reset index:
		giIndexNoName = 0;
	}

	// sort each tree
	SortChildren();

	return true;
}

// Name should be generated by GeneratingName method instead of randome name
void NodeHPChecker::GeneratingName(NodeHPChecker::TreeNode *pNode)
{
	// unsafe method: to do judge whether it is already id of any elements in the document, if yes, increase the index until not
	std::string strIndex;

	// convert number to string
	std::stringstream ConvertStream;
	ConvertStream << giIndexNoName;
	ConvertStream >> strIndex;

	// when find a name that already is an id, we must make sure that it is not in either of document for consistency. Therefore we need to check both files
	while ( pDocument[0]->getDatabase()->idLookup(strBasicName + strIndex, pDocument[0]) != NULL && pDocument[1]->getDatabase()->idLookup(strBasicName + strIndex, pDocument[1]) != NULL)
	{
		// Add random characters in base:
		char aTmp[2];
		aTmp[0] = (char) (rand()%26 + 'a');
		aTmp[1] = '\0';

		strBasicName.append(std::string( aTmp ));
	}

	pNode->SetID(strBasicName + strIndex);
}

void NodeHPChecker::SortChildren()
{
	for (size_t i = 0;i < NUM_TREES;i++)
	{
		if (pRoot[i] != NULL)
			SortChildrenR( (*pRoot[i]) );
	}
}

void NodeHPChecker::SortChildrenR(NodeHPChecker::TreeNode & pNode)
{
	size_t iNumChildren = (pNode.GetChildren()).size();

	// sort children elements
	pNode.SortChildren();

	// for each child, sort them recursively
	for (size_t i = 0;i < iNumChildren;i++)
	{
		SortChildrenR(pNode.GetChildren()[i]);
	}

	return;
}

// compare two trees
bool NodeHPChecker::TransverseTrees(NodeHPChecker::TreeNode &Node1, NodeHPChecker::TreeNode &Node2)
{
	if (Node1.GetID() != Node2.GetID() || Node1.GetChildren().size() != Node2.GetChildren().size())
	{
		return false;
	}
	else
	{
		for (size_t i = 0;i < Node1.GetChildren().size();i++)
		{
			if ( !TransverseTrees(Node1.GetChildren()[i], Node2.GetChildren()[i]) )
				return false;
		}

		return true;
	}
}

bool NodeHPChecker::IsPreserved()
{
	if (pRoot[0] == NULL || pRoot[1] == NULL)
	{
		return false;
	}
	else
	{
		return TransverseTrees( (*pRoot[0]), (*pRoot[1]) );
	}
}

// copy id node tree in visual scene or generate the names
NodeHPChecker::TreeNode * NodeHPChecker::LoadNode(domNode *pDomNode, NodeHPChecker::TreeNode *pParentNode)
{
	TreeNode * pNode = new TreeNode();

	pNode->SetParent(pParentNode);

	// check id of node
	if ( pDomNode->getID() == NULL ) // no ID in this node
	{
		GeneratingName(pNode);
	}
	else
	{
		// put id of node to it
		pNode->SetID( std::string( pDomNode->getID() ) );
	}

	// transverse children of current node
	domNode_Array& aNodes = pDomNode->getNode_array();

	for ( size_t i = 0; i < aNodes.getCount(); i++ ) 
	{
		pNode->AppendChildren( LoadNode(aNodes.get(i), pNode) );
	}

	return pNode;
}

// append child in current tree
void NodeHPChecker::TreeNode::AppendChildren(TreeNode *pChild)
{
	assert(pChild);
	vChildren.push_back(*pChild);
}
	
void NodeHPChecker::TreeNode::SortChildren()
{
	if (vChildren.empty())
		return;
	else
		sort(vChildren.begin(), vChildren.end());
	return;
}